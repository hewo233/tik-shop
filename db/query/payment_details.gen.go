// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/hewo/tik-shop/db/model"
)

func newPaymentDetail(db *gorm.DB, opts ...gen.DOOption) paymentDetail {
	_paymentDetail := paymentDetail{}

	_paymentDetail.paymentDetailDo.UseDB(db, opts...)
	_paymentDetail.paymentDetailDo.UseModel(&model.PaymentDetail{})

	tableName := _paymentDetail.paymentDetailDo.TableName()
	_paymentDetail.ALL = field.NewAsterisk(tableName)
	_paymentDetail.PaymentID = field.NewInt64(tableName, "payment_id")
	_paymentDetail.OrderID = field.NewInt64(tableName, "order_id")
	_paymentDetail.CardNumber = field.NewString(tableName, "card_number")
	_paymentDetail.ExpiryDate = field.NewString(tableName, "expiry_date")
	_paymentDetail.Cvv = field.NewString(tableName, "cvv")

	_paymentDetail.fillFieldMap()

	return _paymentDetail
}

type paymentDetail struct {
	paymentDetailDo

	ALL        field.Asterisk
	PaymentID  field.Int64
	OrderID    field.Int64
	CardNumber field.String
	ExpiryDate field.String
	Cvv        field.String

	fieldMap map[string]field.Expr
}

func (p paymentDetail) Table(newTableName string) *paymentDetail {
	p.paymentDetailDo.UseTable(newTableName)
	return p.updateTableName(newTableName)
}

func (p paymentDetail) As(alias string) *paymentDetail {
	p.paymentDetailDo.DO = *(p.paymentDetailDo.As(alias).(*gen.DO))
	return p.updateTableName(alias)
}

func (p *paymentDetail) updateTableName(table string) *paymentDetail {
	p.ALL = field.NewAsterisk(table)
	p.PaymentID = field.NewInt64(table, "payment_id")
	p.OrderID = field.NewInt64(table, "order_id")
	p.CardNumber = field.NewString(table, "card_number")
	p.ExpiryDate = field.NewString(table, "expiry_date")
	p.Cvv = field.NewString(table, "cvv")

	p.fillFieldMap()

	return p
}

func (p *paymentDetail) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := p.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (p *paymentDetail) fillFieldMap() {
	p.fieldMap = make(map[string]field.Expr, 5)
	p.fieldMap["payment_id"] = p.PaymentID
	p.fieldMap["order_id"] = p.OrderID
	p.fieldMap["card_number"] = p.CardNumber
	p.fieldMap["expiry_date"] = p.ExpiryDate
	p.fieldMap["cvv"] = p.Cvv
}

func (p paymentDetail) clone(db *gorm.DB) paymentDetail {
	p.paymentDetailDo.ReplaceConnPool(db.Statement.ConnPool)
	return p
}

func (p paymentDetail) replaceDB(db *gorm.DB) paymentDetail {
	p.paymentDetailDo.ReplaceDB(db)
	return p
}

type paymentDetailDo struct{ gen.DO }

type IPaymentDetailDo interface {
	gen.SubQuery
	Debug() IPaymentDetailDo
	WithContext(ctx context.Context) IPaymentDetailDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IPaymentDetailDo
	WriteDB() IPaymentDetailDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IPaymentDetailDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IPaymentDetailDo
	Not(conds ...gen.Condition) IPaymentDetailDo
	Or(conds ...gen.Condition) IPaymentDetailDo
	Select(conds ...field.Expr) IPaymentDetailDo
	Where(conds ...gen.Condition) IPaymentDetailDo
	Order(conds ...field.Expr) IPaymentDetailDo
	Distinct(cols ...field.Expr) IPaymentDetailDo
	Omit(cols ...field.Expr) IPaymentDetailDo
	Join(table schema.Tabler, on ...field.Expr) IPaymentDetailDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IPaymentDetailDo
	RightJoin(table schema.Tabler, on ...field.Expr) IPaymentDetailDo
	Group(cols ...field.Expr) IPaymentDetailDo
	Having(conds ...gen.Condition) IPaymentDetailDo
	Limit(limit int) IPaymentDetailDo
	Offset(offset int) IPaymentDetailDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IPaymentDetailDo
	Unscoped() IPaymentDetailDo
	Create(values ...*model.PaymentDetail) error
	CreateInBatches(values []*model.PaymentDetail, batchSize int) error
	Save(values ...*model.PaymentDetail) error
	First() (*model.PaymentDetail, error)
	Take() (*model.PaymentDetail, error)
	Last() (*model.PaymentDetail, error)
	Find() ([]*model.PaymentDetail, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.PaymentDetail, err error)
	FindInBatches(result *[]*model.PaymentDetail, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.PaymentDetail) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IPaymentDetailDo
	Assign(attrs ...field.AssignExpr) IPaymentDetailDo
	Joins(fields ...field.RelationField) IPaymentDetailDo
	Preload(fields ...field.RelationField) IPaymentDetailDo
	FirstOrInit() (*model.PaymentDetail, error)
	FirstOrCreate() (*model.PaymentDetail, error)
	FindByPage(offset int, limit int) (result []*model.PaymentDetail, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IPaymentDetailDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (p paymentDetailDo) Debug() IPaymentDetailDo {
	return p.withDO(p.DO.Debug())
}

func (p paymentDetailDo) WithContext(ctx context.Context) IPaymentDetailDo {
	return p.withDO(p.DO.WithContext(ctx))
}

func (p paymentDetailDo) ReadDB() IPaymentDetailDo {
	return p.Clauses(dbresolver.Read)
}

func (p paymentDetailDo) WriteDB() IPaymentDetailDo {
	return p.Clauses(dbresolver.Write)
}

func (p paymentDetailDo) Session(config *gorm.Session) IPaymentDetailDo {
	return p.withDO(p.DO.Session(config))
}

func (p paymentDetailDo) Clauses(conds ...clause.Expression) IPaymentDetailDo {
	return p.withDO(p.DO.Clauses(conds...))
}

func (p paymentDetailDo) Returning(value interface{}, columns ...string) IPaymentDetailDo {
	return p.withDO(p.DO.Returning(value, columns...))
}

func (p paymentDetailDo) Not(conds ...gen.Condition) IPaymentDetailDo {
	return p.withDO(p.DO.Not(conds...))
}

func (p paymentDetailDo) Or(conds ...gen.Condition) IPaymentDetailDo {
	return p.withDO(p.DO.Or(conds...))
}

func (p paymentDetailDo) Select(conds ...field.Expr) IPaymentDetailDo {
	return p.withDO(p.DO.Select(conds...))
}

func (p paymentDetailDo) Where(conds ...gen.Condition) IPaymentDetailDo {
	return p.withDO(p.DO.Where(conds...))
}

func (p paymentDetailDo) Order(conds ...field.Expr) IPaymentDetailDo {
	return p.withDO(p.DO.Order(conds...))
}

func (p paymentDetailDo) Distinct(cols ...field.Expr) IPaymentDetailDo {
	return p.withDO(p.DO.Distinct(cols...))
}

func (p paymentDetailDo) Omit(cols ...field.Expr) IPaymentDetailDo {
	return p.withDO(p.DO.Omit(cols...))
}

func (p paymentDetailDo) Join(table schema.Tabler, on ...field.Expr) IPaymentDetailDo {
	return p.withDO(p.DO.Join(table, on...))
}

func (p paymentDetailDo) LeftJoin(table schema.Tabler, on ...field.Expr) IPaymentDetailDo {
	return p.withDO(p.DO.LeftJoin(table, on...))
}

func (p paymentDetailDo) RightJoin(table schema.Tabler, on ...field.Expr) IPaymentDetailDo {
	return p.withDO(p.DO.RightJoin(table, on...))
}

func (p paymentDetailDo) Group(cols ...field.Expr) IPaymentDetailDo {
	return p.withDO(p.DO.Group(cols...))
}

func (p paymentDetailDo) Having(conds ...gen.Condition) IPaymentDetailDo {
	return p.withDO(p.DO.Having(conds...))
}

func (p paymentDetailDo) Limit(limit int) IPaymentDetailDo {
	return p.withDO(p.DO.Limit(limit))
}

func (p paymentDetailDo) Offset(offset int) IPaymentDetailDo {
	return p.withDO(p.DO.Offset(offset))
}

func (p paymentDetailDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IPaymentDetailDo {
	return p.withDO(p.DO.Scopes(funcs...))
}

func (p paymentDetailDo) Unscoped() IPaymentDetailDo {
	return p.withDO(p.DO.Unscoped())
}

func (p paymentDetailDo) Create(values ...*model.PaymentDetail) error {
	if len(values) == 0 {
		return nil
	}
	return p.DO.Create(values)
}

func (p paymentDetailDo) CreateInBatches(values []*model.PaymentDetail, batchSize int) error {
	return p.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (p paymentDetailDo) Save(values ...*model.PaymentDetail) error {
	if len(values) == 0 {
		return nil
	}
	return p.DO.Save(values)
}

func (p paymentDetailDo) First() (*model.PaymentDetail, error) {
	if result, err := p.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.PaymentDetail), nil
	}
}

func (p paymentDetailDo) Take() (*model.PaymentDetail, error) {
	if result, err := p.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.PaymentDetail), nil
	}
}

func (p paymentDetailDo) Last() (*model.PaymentDetail, error) {
	if result, err := p.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.PaymentDetail), nil
	}
}

func (p paymentDetailDo) Find() ([]*model.PaymentDetail, error) {
	result, err := p.DO.Find()
	return result.([]*model.PaymentDetail), err
}

func (p paymentDetailDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.PaymentDetail, err error) {
	buf := make([]*model.PaymentDetail, 0, batchSize)
	err = p.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (p paymentDetailDo) FindInBatches(result *[]*model.PaymentDetail, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return p.DO.FindInBatches(result, batchSize, fc)
}

func (p paymentDetailDo) Attrs(attrs ...field.AssignExpr) IPaymentDetailDo {
	return p.withDO(p.DO.Attrs(attrs...))
}

func (p paymentDetailDo) Assign(attrs ...field.AssignExpr) IPaymentDetailDo {
	return p.withDO(p.DO.Assign(attrs...))
}

func (p paymentDetailDo) Joins(fields ...field.RelationField) IPaymentDetailDo {
	for _, _f := range fields {
		p = *p.withDO(p.DO.Joins(_f))
	}
	return &p
}

func (p paymentDetailDo) Preload(fields ...field.RelationField) IPaymentDetailDo {
	for _, _f := range fields {
		p = *p.withDO(p.DO.Preload(_f))
	}
	return &p
}

func (p paymentDetailDo) FirstOrInit() (*model.PaymentDetail, error) {
	if result, err := p.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.PaymentDetail), nil
	}
}

func (p paymentDetailDo) FirstOrCreate() (*model.PaymentDetail, error) {
	if result, err := p.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.PaymentDetail), nil
	}
}

func (p paymentDetailDo) FindByPage(offset int, limit int) (result []*model.PaymentDetail, count int64, err error) {
	result, err = p.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = p.Offset(-1).Limit(-1).Count()
	return
}

func (p paymentDetailDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = p.Count()
	if err != nil {
		return
	}

	err = p.Offset(offset).Limit(limit).Scan(result)
	return
}

func (p paymentDetailDo) Scan(result interface{}) (err error) {
	return p.DO.Scan(result)
}

func (p paymentDetailDo) Delete(models ...*model.PaymentDetail) (result gen.ResultInfo, err error) {
	return p.DO.Delete(models)
}

func (p *paymentDetailDo) withDO(do gen.Dao) *paymentDetailDo {
	p.DO = *do.(*gen.DO)
	return p
}
